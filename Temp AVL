#include<stdio.h>
#include<stdlib.h>
#define MAX 20

typedef struct treenode{

    int data;
    int height;
    struct treenode * left;
    struct treenode * right;
  
}treenode;

typedef struct BST{

    treenode * head;
    int count;
  
}BST;

BST * createtree(){
  
    BST * bt;
    bt = (BST*)malloc(sizeof(BST));
    bt->head = NULL;
    bt->count = 0;
    return bt;

}

void initialize (BST * bt, treenode * root){
    
    bt->head = root;
    bt->count = 1;
    
}

void deletetree (BST * bt, treenode * root){
    
    bt->head = NULL;
    bt->count = 0;
    root->left = NULL;
    root->right = NULL;
    
}

treenode * createnode(int number){
        
    treenode * newnode;
    newnode = (treenode*)malloc(sizeof(treenode));
    newnode->data = number;
    newnode->height = 0;
    newnode->right = NULL;
    newnode->left = NULL;
    return newnode;
  
}

int computeheight (treenode * root, int lh, int rh){
    
    if(root != NULL){
    
        lh = computeheight(root->left, lh, rh);
        rh = computeheight(root->right, lh, rh);
        root->height = lh-rh;
        return lh>rh ? lh+1 : rh + 1;
    }
    
    else{
    
        return lh;
    }
    
}    

treenode * rotateleft(treenode * prev, treenode * root, treenode * subroot){
    
    root->right = subroot->left;
    subroot->left = root;
    
    if(prev == NULL){
        return subroot;
    }
    
    if(root->data < prev->data){
        prev->left = subroot;
        return subroot;
    }
    
    else if(root->data > prev->data){
        prev->right = subroot;
        return subroot;
    }
    
    else{
        return subroot;
    }

}

treenode * rotateright(treenode * prev, treenode * root, treenode * subroot){
    
    root->left = subroot->right;
    subroot->right = root;
    
    if(prev ==  NULL){
        return subroot;    
    }
    
    if(root->data > prev->data){
        prev->right = subroot;
        return subroot;
    }
    
    else if(root->data < prev->data){
        prev->left = subroot;
        return subroot;
    }
    
    else{
        return subroot;
    }

}

treenode * balance(treenode * prev, treenode * root, treenode * subroot){
    
    if(root->height == 2){
        
        if(subroot->height == 1 || subroot->height == 0){
            root = rotateright(prev, root, subroot);
            return root;
        }
        
        else{ 
            subroot = rotateleft(root, subroot, subroot->right);
            balance(prev, root, subroot);
        }
        
    }
    
    else if(root->height == -2){
        
        if(subroot->height == -1 || subroot->height == 0){
            root = rotateleft(prev, root, subroot);
            return root;
        }
        
        else{
            subroot = rotateright(prev, root, subroot);
            balance(prev, root, subroot);
        }
        
    }
    
    else{
        
        return;
    }
    
}

treenode * insert(treenode * prev, treenode * root, treenode * newnode, int number){
    
    if(root->data > number){
        
        if(root->left != NULL){
            insert(root, root->left, newnode, number);
            computeheight(root, 0, 0);
            root = balance (prev, root, root->left);
            return root;
        }
        
        else{
            root->left = newnode;
            computeheight(root, 0, 0);
            return root;
        }
        
    }
        
    else{
        
        if(root->right != NULL){ 
            insert(root, root->right, newnode, number);
            computeheight(root, 0, 0);
            root = balance(prev, root, newnode);
            return root;
        }
        
        else{
            root->right = newnode;
            computeheight(root, 0, 0) * -1;
            return root;
            
        }
    
    }
    
}



void DepthFirstSearch(treenode * root){
    
    if(root != NULL){
        
        printf("%d\n", root->data);
        DepthFirstSearch(root->left);
        DepthFirstSearch(root->right);
        return;
        
    }
    
    return;
    
}

int main(){
    
    BST * bt;
    treenode * root, * newnode, * prev, *subroot;
    bt = (BST*)malloc(sizeof(BST));
    createtree(bt);
    prev = bt->head;
    root = createnode(16);
    initialize(bt, root);
    newnode = createnode(14);
    subroot = insert(prev, root, newnode, 14);
    newnode = createnode(12);
    subroot = insert(prev, root, newnode, 12);
    DepthFirstSearch(subroot);
    return 0;
    
}
