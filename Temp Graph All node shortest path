#include<stdio.h>
#include<stdlib.h>
#define MAX 20

typedef struct Graph{
    
    struct graphnode * head;
    struct graphnode * solution;
    int count;
    
}Graph;

typedef struct graphnode{
    
    int data;
    int repeat;
    int distance;
    struct graphnode * vertexpointer;
    struct graphnode * edgepointer;
    
}graphnode;

typedef struct Stack{
    
    int listdistance[MAX];
    graphnode * listnode [MAX];
    int topnode;
    int topdistance;

}Stack;

Stack * createstack(){
    
    Stack * nodepath;
    nodepath = (Stack*)malloc(sizeof(Stack));
    return nodepath;
    
}


int stacktop(Stack * s){
    
    int data;
    data = s->listdistance[s->topdistance];
    return data;
}

Stack * initializestack(){
    
    int i;
    Stack * nodepath;
    nodepath = (Stack*)malloc(sizeof(Stack));
    nodepath->topnode = 0;
    nodepath->topdistance = 0;

    for(i=0;i< MAX; i++){
        nodepath->listnode[i] = NULL;
    }
    
    for(i=0;i< MAX; i++){
        nodepath->listdistance[i] = 0;
    }
    return nodepath;
}

void pushnodelist(Stack * nodepath, graphnode * node){
    
   nodepath->topnode = nodepath->topnode + 1;
   nodepath->listnode[nodepath->topnode] =   node;
   
}

void pushdistancelist (Stack * nodepath, int distance){
    
    int prevdistance;
    prevdistance = nodepath->listdistance[nodepath->topdistance];
    nodepath->topdistance = nodepath->topdistance + 1;
    nodepath->listdistance[nodepath->topdistance] =  prevdistance + distance;
}

graphnode * popnodelist(Stack * nodepath){
    
    graphnode * node;
    node = nodepath->listnode[nodepath->topnode-1];
    nodepath->topnode = nodepath->topnode - 1;
    return node;
    
}

int popdistancelist(Stack * nodepath){
    
    int distance;
    distance = nodepath->listdistance[nodepath->topdistance-1];
    nodepath->topdistance = nodepath->topdistance - 1;
    return distance;
    
}

Graph * creategraph(){
    
    Graph * graph;
    graph = (Graph*)malloc(sizeof(Graph));
    graph->head = NULL;
    graph->count = 0;
    return graph;
    
}

void clearpath(){
    
    Graph * graph;
    graphnode * source;
    
    source = graph->head;
    while(source != NULL){
        
        source->repeat = 0;
        source = source->vertexpointer;
        
    }
}

graphnode * findposition(graphnode * vertex, int number){
    
    while(vertex->data != number){
        
        vertex = vertex->vertexpointer;
    }
    return vertex;
}

graphnode * insert(Graph * graph, graphnode * vertex){
    
    graphnode * vertex1;
    vertex1 = graph->head;
    if(graph->head == NULL){
        
        graph->head = vertex;
        return vertex;
    }
    
    while(vertex1->vertexpointer != NULL){
        
        vertex1 = vertex1->vertexpointer;
    }
    vertex1->vertexpointer = vertex;
    return vertex;
}

graphnode * createvertex(int number){
    
    graphnode * vertex;
    vertex = (graphnode*)malloc(sizeof(graphnode));
    vertex->data = number;
    vertex->vertexpointer = NULL;
    vertex->edgepointer = NULL;
    return vertex;

}

void createedge(graphnode * vertex, int number1, int number2){
    
    graphnode * vertex1, * vertex2, * vertex3;
    vertex1 = findposition(vertex, number1);
    vertex2 = findposition(vertex, number2);
    vertex3 = createvertex(number2);

    while(vertex1->edgepointer != NULL){
        
        vertex1 = vertex1->edgepointer;
    }
    vertex1->edgepointer = vertex3;
    vertex3->vertexpointer = vertex2;
     
     
}

void createtree(graphnode * source, graphnode * destination, int distance){
    
    Graph * graph;
    graphnode * start, * prev, *prev2, * next;
    
    if(graph->solution == NULL){
        graph->solution = source;
    }
    
    start = graph->solution;
    while(start != NULL){
        
        if(start->data = source->data){
            
            prev = source;
            next = source->edgepointer;
            while(next != NULL){
                
                if(next->data = destination->data){
                    if(next->distance > distance){
                        next->distance = distance;
                        return;
                    }
                }
                
                else{
                    prev2 = next;
                    next = next->edgepointer;
                }
            }
            
            prev2->edgepointer = destination;
            destination->distance = distance;
        }   
        
        else{
            
            prev = start;
            start = start->vertexpointer;
        }
    }
    
}

void displaypath(){
    
    Graph * graph;
    graphnode * source, * destination;
    
    source = graph->solution;
    
    while(source != NULL){
        
        destination = source->edgepointer;
        
        while(destination != NULL){
            
            printf("%d-", source->data);
            printf("%d\n", destination->data);
            printf("%d\n", destination->distance);
            destination = destination->edgepointer;
        }
        
        source = source->vertexpointer;
    }
}

void SmallestPath(graphnode * source, graphnode * destination, int distance){
    
    graphnode * temp, * next;
    Stack * nodepath;
    nodepath = initializestack();
    
    while(source != NULL){
        
        pushnodelist(nodepath, source);
        destination = source->edgepointer;
                
            while(destination != NULL){
                
                if(destination->vertexpointer->repeat != 1){
                        
                        while(temp != NULL){
                        
                            temp = destination->vertexpointer;
                            temp->repeat = 1;
                            pushdistancelist(nodepath, destination->data);
                            pushnodelist(nodepath, temp);
                            distance = stacktop(nodepath);
                            createtree(source, temp, distance);
                            temp = temp->edgepointer;
                            destination = temp;
                        }    
                }
                
                else{
                        
                        while(destination->vertexpointer->repeat == 1){
                    
                            if(destination-> edgepointer == NULL){
                                 break;
                            }
                    
                            else{
                                temp = destination->vertexpointer;
                                destination = destination->edgepointer;
                            }
                        }
                }
                
                popdistancelist(nodepath);
                destination = popnodelist(nodepath);
                destination = destination->edgepointer;
            }
    
        clearpath(source);
        source = source->vertexpointer;
    }
}

int main(){
    
    Graph * graph;
    graphnode * vertex;
    graph = creategraph();
    vertex = createvertex(1);
    insert(graph, vertex);
    vertex = createvertex(2);
    insert(graph, vertex);
    vertex = createvertex(3);
    createedge(graph->head, 1, 2);
    createedge(graph->head, 1, 3);
    createedge(graph->head, 2, 3);
    SmallestPath(graph->head, NULL, 0);
    displaypath();
    return 0;
   
}
